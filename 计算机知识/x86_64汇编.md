## 语法风格
- AT&T，GUN工具使用，在Unix上
`movl %esp, %ebp`
源操作数在前，目的操作数在后

- intel，再Windows系统上
`movq ebp, esp`
源操作数在后，目的操作数在前

| Intel Code                   | AT&T Code                         |
| ---------------------------- | --------------------------------- |
| mov     eax,1                | movl    $1,%eax                   |
| mov     ebx,0ffh             | movl    $0xff,%ebx                |
| int     80h                  | int     $0x80                     |
| mov     ebx, eax             | movl    %eax, %ebx                |
| mov     eax,[ecx]            | movl    (%ecx),%eax               |
| mov     eax,[ebx+3]          | movl    3(%ebx),%eax              |
| mov     eax,[ebx+20h]        | movl    0x20(%ebx),%eax           |
| add     eax,[ebx+ecx*2h]     | addl    (%ebx,%ecx,0x2),%eax      |
| lea     eax,[ebx+ecx]        | leal    (%ebx,%ecx),%eax          |
| sub     eax,[ebx+ecx*4h-20h] | subl    -0x20(%ebx,%ecx,0x4),%eax |
| mov     rax, OFFSET msg      | mov     $msg, rax                 |


## 操作数位宽
### AT&T
使用指令后缀的方法
`movzbl` 源操作数1byte，目的操作数4bytes，使用0扩展。
`movl` 源操作数和目的操作数均为4bytes

`b w l q` 1 2 4 8 byte

### Intel
- `PTR`，表示指针，pointer的简写。
- `BYTE`: 字节，8位。计算机的最小存储单元。
- `WORD`: 字，2bytes，16位（由于Intel的x86系列芯片起源与8086，那时的word只有16bit，因此word在x86的世界里，就是16bits，一直沿用至今）
- `DWORD`: 双字，4bytes，32位
- `QWORD`: 8bytes，64位
- `XMMWORD`：16bytes，128位


## Adress modes
![](Pasted%20image%2020240721224246.png)
- `symbol_name(%rip)`偏移量将会被自动计算出来，这种寻址方式称为“基于RIP的相对寻址”（RIP-relative addressing），它是x86_64架构中用于提高代码位置无关性（Position Independent Code, PIC）的一种技术。通过使用`%rip`寄存器作为基址，即使代码被加载到内存中的不同位置，只要相对偏移量保持不变，那么指令就能正确地访问到数据。这对于共享库和动态加载的代码特别重要。
- `offset(base, index, scale)`


## 指令集
- `cvttsd2si` Convert Truncation Scalar Double floating-point value To Signed Integer.
## 函数调用规约
### System V AMD64
- 参数传递
	- 定点数：前六个定点数参数来自寄存器，分别是：`rdi, rsi, rdx, rcx, r8, r9`；第七个及往后的定点数参数来自caller的栈帧
	- 浮点数：前八个浮点数参数来此寄存器，分别是：`xmm0~xmm7`；第九个及往后的浮点参数来自caller的栈帧
	- caller通过寄存器和caller栈帧向callee传参，首先将参数从右往左传递给中间媒介（在caller中完成），再从中间媒介从左往右传递给callee（在callee中完成）
- 返回值
	- 定点数：存在`rax`中
	- 浮点数：存在`xmm0`中


## 伪指令
伪指令的格式：`.伪指令 [参数]`
- `.long <literal>` 定义一个4字节的字面量


## 理解
- 每一个进程都维护一个调用栈，调用栈由栈帧组成，栈帧用于保存函数调用期间的信息，包括参数、局部变量、返回地址等。调用栈是进程内存空间的一部分，进程内存空间还包括代码段、数据段等。
- 自定义类型的成员函数在代码中没有使用的话，编译器不会对其编译；自定义类型的成员变量不具备可编译性。
- 程序中出现的字面量必定都会出现在编译后的程序中，有的在指令中，有的在内存中。例如：
```
int a = 1001;
movl $1001, -4(%rbp)       ; 字面量直接在指令中给出

double b = 1.0;
movsd .LC0(%rip), %xmm0    ; 在内存取浮点数字面量
movsd %xmm0, -16(%rbp)     ; 将浮点数存到b变量的内存位置；字节对齐
.LC0:
	.long 1065353216       ;0x3f800000 = 1.0000000f
```
# 数据类型
## 基本数据类型
1. `Boolean`
2. `Number`
3. `String`
4. `Undefined`
5. `Symbol`
6. `Bignum`

## 复合数据类型
1. `Function`
2. `Object`
	- `Object`
	- `Array`
	- `Date`
	- `RegExp`

注：`null` 是 `object` 类型对一个**常量**。


# Object的创建与访问
Object是变量的容器，保存变量名以及变量值。变量具体可以是普通变量、函数、数组、对象等。
## 创建对象
### 通过对象字面量创建
`var obj = {key: value, key: value};`
如果某个变量是函数，则有两种方法存储：
1. 定义匿名函数再赋值
```Javascript
var obj = {
	myFunc = function(){
		// funciton body
	}
}
// obj = {myFunc: f}
```
2. 直接定义函数
```Javascript
var obj = {
	function myFunc(){
		// function body
	}
}
// obj = {myFunc: f}
```
这两种方法均满足"变量名=值"的要求，所以均可行。

### 通过Object创建
```Javascript
var str = new Object("hello world");
```

### 通过对象构造器创建
```Javascript
function Person(firstName, lastName, age){
	this.firstName = firstName;
	this.lastName = lastName;
	this.age = age;
}

var person = new Person("Hao", "Lu", 21);
console.log(person);
```
![函数new与不new的区别](经验、技巧.md#函数new与不new的区别)

## 访问对象
1. `obj.key`
2. `obj[key]`


# 数组的创建与访问
Javascript中的数组**元素类型可以不同**。
## 创建数组
1. `var arr1 = [e1, e2, e3];` 
2. `var arr2 = new Array(e1, e2, e3)`
3. 创建后再赋值
```Javascript
var arr3 = new Array();
arr3[1] = 1;
arr3[2] = 2;
```
## 访问数组
通过索引访问：`arr[i]`
## 数组的属性和方法
数组有一个属性：`lenght`，记录着数组的长度。

可以为数组添加个性化的方法：
```Javascript
var arr = new Array(1, 2, 3);
Array.prototype.printArr = function(){
	console.log(arr[0]);
	for (let i = 1; i < arr.lenght; i++){
		console.log(' ', arr[i]);
	}
}

arr.printArr();
// output:
// 1 2 3
```
上述相当于给`Array`类添加了一个`printArr()`方法，所有的`Array`实例(arr1, arr2...)都将拥有此方法。
### 常用方法
- `indexOf(<value>)` 返回值`value`的索引，不存在则返回-1
- `concat(...items)` items为数组，在原数组上追加items数组的元素，返回新的数组，即将多个数组合并。
- `toString()` 转换为字符串，会将`[]`去掉。
# 箭头函数 =>
`func = para => para * para`等价于 :
``` js
function func(para){
	return para * para
}

func = (a, b) => { 
let i = 1; ({"name": a, "age": b}) 
}
// 1. 当有多个参数时，使用圆括号
// 2. 当有多条语句时，使用花括号
// 3. 当需要返回对象时，为了和语句块区分，需要将对象用圆括号包裹
```
箭头函数不会在定义时this值便已经确定，值为定义时所在词法作用域下this的值。而普通函数的this根据调用方式的不同而不同，普通调用时，this指向window对象，作为方法调用时，this指向调用它的对象。

只有存在HTML时，window对象才有定义。
# ... 运算符
相当于python中的解包
- `...iterable` 把iterable解包为以逗号分隔的seqence
- `...seqence` 把seqence 合并为一个iterable，常用于函数的不定长参数


# 同步与异步
同步：操作各阶段是连续的
异步：操作各阶段不连续，到某个阶段可能会挂起，转而执行其他操作。

异步操作中某个步骤不会占用CPU资源，需要等待世界，此时可以挂起这个操作，转而执行其他操作。当挂起的哪个步骤就绪后，根据如何执行操作的后续步骤，可分为一下几种，称为实现异步的方式
- 回调
- 事件监听
- 发布/订阅
- Promise

## promise
promise 对象是被封装的异步任务，该异步任务接受两个参数，分别是任务执行成功时的回调函数`resolve`和任务执行失败时的回调函数`reject`。所有`promise`对象本质上还是异步任务

# 闭包(closure)
在函数内部声明了对象，该函数执行后其执行上下文(context)的与该对象有关的变量不会立即销毁。

# 立即调用函数表达式(IIFE)
当一个函数只需要执行一次时，可以使用，以避免全局命名空间的污染
```Javascript
var add = (function(a, b){
	var counter = 0;
	return function(){
		return ++counter;	
	}
})();
```
这里我们想要获得内部加计时器的函数必须先调用外部函数，可常规调用必要通过"函数名()"的方式，我们不想再全局空间在增加一个只会调用一次的函数名称，此时可使用立即函数调用表达式。

普通调用：函数名()
立即调用函数：(函数定义)(), 省去了函数名，减少了命名空间重名的风险


# Generator
Generator函数定义语法：`function* funcName(){yield ...}`
Generator函数相当于包含多个状态的容器，它返回一个指向`Iterator`对象的指针。

通过指针的`next()`方法一次访问Generator的所有状态，`next()`方法返回一个对象字面量`{value:<每一个状态的值>, done:false|true}`，状态由函数体内的`yield`定义，一般是表达式，所以`value`的值就是该表达式的值；`done`表示是否为最后一个状态，当为`true`时，表明是最后一个状态。

# 模块导入导出
## 深拷贝
深拷贝导入导出使用`export`和`import`关键字事项导出和导入，导出的变量是原变量的引用，在外部被修改，原变量也会被修改。

此外，`import`在编译时加载。

属于`ECMAScript`标准
### 导出
1. 导出单个成员
```Javascript
// 导出函数 
export function sayHello(name) { 
	console.log(`Hello, ${name}!`); 
} 

// 导出变量 
export const greeting = "Hello, world!"; 

// 导出类 
export class Greeter { 
greet(name) { 
	console.log(`Hello, ${name}!`); 
	} 
}
```
2. 导出多个成员
```Javascript
// 1.使用多个export
// 2.使用花括号
export {sayHello, greeting, Greeter}
```
3. 默认导出
每个文件文件都允许有一个默认导出，导入默认导出时，可以不必带花括号。
```Javascript
// 默认导出
export function Test(){ code...}

// 导入默认导出，无需使用大括号
import Test from "./mods";
```

### 导入
```Javascript
import {sayHello, greeting} form "./mods";

// 全部导入
import * as myMods from "./mods";
myMods.sayHello();
```


## 浅拷贝
浅拷贝使用`modules.export`和 `require` 关键字实现导出导入，导出的变量是原变量的拷贝，不会影响原变量。

属于`CommonJs`标准。
### 导出
```Javascript
function f1(a, b){
    return a + b;
}

function f2(a, b){
    return a - b;
}

module.exports = {
    add : f1, 
    sub : f2
}
```
`module.exports` 对象定义了当前文件导出的内容，对象的属性是导出变量在外部的名称，属性对应的值是当前模块中的变量。

### 导入
```Javascript
var math = require("./test");
console.log(math.add(1, 2));
console.log(math.sub(3, -1));
```
`require(path)`返回一个对象，通过该对象，我们可以使用其他模块导出的变量，这其实就相当于一个命名空间。
# nditer(array-like)
返回一个可迭代对象，遍历最内部元素。比如二维数组，不是遍历其中的一维数组，而是遍历一维数组里的元素。
# rand(x, y, z)
``` python
arr = np.random.rand(3, 3, 3)
# 创建一个形状为 3x3x3 的数组, 元素值为随机数
```
### randn(x1, x2, ..., xn)
N-维数组，元素数值服从正太分布

# 结论
1. `shape: (n,)` 对于这样的一维形状，当其作为矩阵时，既可以看作 `nx1` 形状， 也可以看作 `1xn` 形状，取决于具体表达式，numpy总是会自动匹配，让表达式有意义，如果两种形状都会使表达式无意义，则会报错。

# 维度
几个方括号包围，就有几个维度
``` python
数组被几个方括号包围，就有几个维度
arr1 = np.array([1, 2]) # (2,)
arr2 = np.array([[[1,2]], [[3, 4]]]) # (2, 1, 2)
```


# 索引
1. **普通索引**
```MATLAB
arr[index1, index2, ..., indexn]

# 指定各轴上的索引，组成最终的索引
```

2. **切片**
```MATLAB
# arr(slice, slice, ..., slice)

arr[1:4, 2:5]
```
2到4行，3到5列交点出的元素都将被索引到。`zero-index, [start, end)`
**推广：**
现在各个轴上通过冒号运算符产生该轴上的索引：`([1,2,3,4], [2,3,4,5])`.各轴上将产生一个由索引组成的向量，假如轴1产生的向量为v1，轴2产生的向量为v2，一次类推，对v1，v2，...vn向量作笛卡尔积，得到有序对集合，该集合中的每一个有序对都是索引。

3. **索引列表**
```MATLAB
arr([1,3,5], [2,4,6], ..., [x,x,x,...,])
```

>[!warning]
>在python中，手动给出的索引列表与MATLAB中的不同，它不做笛卡尔积，而是需要各轴向量（索引列表）长度相等，然后将各轴对应位置的分量组成一个有序对，作为元素的索引，所以索引列表有多长，就有多少个元素被索引。


>[!note] 
>在某个轴上不给索引，默认选中该轴上的所有索引，为 `:`。
